---
title: 长短游戏帧处理
date: 2023-05-16 18:40:08 +0800
categories: [Uncategories,性能优化]
image:
  path: https://raw.githubusercontent.com/Rootjhon/img_note/empty/202305161818350.png
tags: [Frame Pacing,长短帧]
# Ref
# - https://developer.android.com/games/sdk/frame-pacing

---

## 正确的 30 Hz 帧同步

当在 60 Hz 设备上以 30 Hz 渲染时，Android 上的理想情况如图 1 所示。SurfaceFlinger 锁存新的图形缓冲区（如果存在）（图中的 NB 表示“无缓冲区”存在并且重复前一个）。

![60 Hz 设备上 30 Hz 的理想帧同步](https://raw.githubusercontent.com/Rootjhon/img_note/empty/202305161812845.png)



**图 1.** 60 Hz 设备上 30 Hz 的理想帧同步

## 短游戏帧导致卡顿

在大多数现代设备上，游戏引擎依赖于平台编排器提供的滴答声来驱动帧的提交。然而，仍然存在由于短帧而导致帧步调不佳的可能性，如图 2 所示。短帧后跟长帧会被播放器视为卡顿。

![短游戏帧](https://raw.githubusercontent.com/Rootjhon/img_note/empty/202305161812021.png)

**图 2.**短游戏帧 C 导致帧 B 仅呈现一帧，然后是多个 C 帧

Frame Pacing 库通过使用表示时间戳解决了这个问题。该库使用表示时间戳扩展 [`EGL_ANDROID_presentation_time`](https://www.khronos.org/registry/EGL/extensions/ANDROID/EGL_ANDROID_presentation_time.txt) ， [`VK_GOOGLE_display_timing`](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VK_GOOGLE_display_timing.html) 因此帧不会提前显示，如图 3 所示。

![image-20230516181501696](https://raw.githubusercontent.com/Rootjhon/img_note/empty/202305161815071.png)

**图 3.**游戏帧 B 呈现两次以获得更流畅的显示

## 长帧会导致卡顿和延迟

当显示工作负载花费的时间比应用程序工作负载长时，额外的帧将添加到队列中。这会再次导致卡顿，并且还可能由于缓冲区填充而导致额外的帧延迟（见图 4）。该库既消除了卡顿现象，也消除了额外的延迟帧。

![image-20230516181731046](https://raw.githubusercontent.com/Rootjhon/img_note/empty/202305161817555.png)

**图 4.**长帧 B 给出了 2 个帧 A 和 B 的不正确步调

该库通过使用同步栅栏 ([`EGL_KHR_fence_sync`](https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_fence_sync.txt) 和 [`VkFence`](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkFence.html)) 将等待注入应用程序来解决此问题，以允许显示管道赶上进度，而不是让背压累积。框架 A 仍然呈现一个额外的框架，但框架 B 现在可以正确呈现，如图 5 所示。

![image-20230516181834501](https://raw.githubusercontent.com/Rootjhon/img_note/empty/202305161818350.png)

**图 5.**帧 C 和 D 等待呈现



